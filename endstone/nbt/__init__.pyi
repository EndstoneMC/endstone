"""
Classes relating to the NBT data format.
"""

import collections
import enum
import typing

__all__ = [
    "ByteArrayTag",
    "ByteTag",
    "DoubleTag",
    "FloatTag",
    "IntArrayTag",
    "IntTag",
    "LongTag",
    "ShortTag",
    "StringTag",
    "Tag",
]

class Tag:
    class Type(enum.IntEnum):
        END = 0
        BYTE = 1
        SHORT = 2
        INT = 3
        LONG = 4
        FLOAT = 5
        DOUBLE = 6
        BYTE_ARRAY = 7
        STRING = 8
        LIST = 9
        COMPOUND = 10
        INT_ARRAY = 11

    END = Type.END
    BYTE = Type.BYTE
    SHORT = Type.SHORT
    INT = Type.INT
    LONG = Type.LONG
    FLOAT = Type.FLOAT
    DOUBLE = Type.DOUBLE
    BYTE_ARRAY = Type.BYTE_ARRAY
    STRING = Type.STRING
    LIST = Type.LIST
    COMPOUND = Type.COMPOUND
    INT_ARRAY = Type.INT_ARRAY

class ByteTag:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @property
    def value(self) -> int: ...
    @typing.overload
    def __eq__(self, arg0: ByteTag) -> bool: ...
    @typing.overload
    def __eq__(self, arg0: int) -> bool: ...
    @typing.overload
    def __eq__(self, arg0: int) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: ByteTag) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: int) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: int) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __int__(self) -> int: ...

class ShortTag:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @property
    def value(self) -> int: ...
    @typing.overload
    def __eq__(self, arg0: ShortTag) -> bool: ...
    @typing.overload
    def __eq__(self, arg0: int) -> bool: ...
    @typing.overload
    def __eq__(self, arg0: int) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: ShortTag) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: int) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: int) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __int__(self) -> int: ...

class IntTag:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @property
    def value(self) -> int: ...
    @typing.overload
    def __eq__(self, arg0: IntTag) -> bool: ...
    @typing.overload
    def __eq__(self, arg0: int) -> bool: ...
    @typing.overload
    def __eq__(self, arg0: int) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: IntTag) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: int) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: int) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __int__(self) -> int: ...

class LongTag:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @property
    def value(self) -> int: ...
    @typing.overload
    def __eq__(self, arg0: LongTag) -> bool: ...
    @typing.overload
    def __eq__(self, arg0: int) -> bool: ...
    @typing.overload
    def __eq__(self, arg0: int) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: LongTag) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: int) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: int) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __int__(self) -> int: ...

class FloatTag:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, value: float) -> None: ...
    @property
    def value(self) -> float: ...
    @typing.overload
    def __eq__(self, arg0: FloatTag) -> bool: ...
    @typing.overload
    def __eq__(self, arg0: float) -> bool: ...
    @typing.overload
    def __eq__(self, arg0: float) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: FloatTag) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: float) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: float) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __float__(self) -> float: ...

class DoubleTag:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, value: float) -> None: ...
    @property
    def value(self) -> float: ...
    @typing.overload
    def __eq__(self, arg0: DoubleTag) -> bool: ...
    @typing.overload
    def __eq__(self, arg0: float) -> bool: ...
    @typing.overload
    def __eq__(self, arg0: float) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: DoubleTag) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: float) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: float) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __float__(self) -> float: ...

class ByteArrayTag:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, iterable: collections.abc.Iterable) -> None: ...
    @typing.overload
    def __init__(self, buffer: collections.abc.Buffer) -> None: ...
    def __buffer__(self, flags) -> None:
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
        ...
    def __release_buffer__(self, buffer) -> None:
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
        ...
    def clear(self) -> None: ...
    def append(self, value: int) -> None: ...
    def extend(self, iterable: collections.abc.Iterable) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, arg0: int) -> int: ...
    def __setitem__(self, arg0: int, arg1: int) -> None: ...
    def __iter__(self) -> collections.abc.Iterator[int]: ...
    @typing.overload
    def __eq__(self, arg0: ByteArrayTag) -> bool: ...
    @typing.overload
    def __eq__(self, arg0: list[int]) -> bool: ...
    @typing.overload
    def __eq__(self, arg0: list[int]) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: ByteArrayTag) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: list[int]) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: list[int]) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __bytes__(self) -> bytes: ...

class StringTag:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, value: str) -> None: ...
    @property
    def value(self) -> str: ...
    @typing.overload
    def __eq__(self, arg0: StringTag) -> bool: ...
    @typing.overload
    def __eq__(self, arg0: str) -> bool: ...
    @typing.overload
    def __eq__(self, arg0: str) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: StringTag) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: str) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: str) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

class IntArrayTag:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, iterable: collections.abc.Iterable) -> None: ...
    def clear(self) -> None: ...
    def append(self, value: int) -> None: ...
    def extend(self, iterable: collections.abc.Iterable) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, arg0: int) -> int: ...
    def __setitem__(self, arg0: int, arg1: int) -> None: ...
    def __iter__(self) -> collections.abc.Iterator[int]: ...
    @typing.overload
    def __eq__(self, arg0: IntArrayTag) -> bool: ...
    @typing.overload
    def __eq__(self, arg0: list[int]) -> bool: ...
    @typing.overload
    def __eq__(self, arg0: list[int]) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: IntArrayTag) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: list[int]) -> bool: ...
    @typing.overload
    def __ne__(self, arg0: list[int]) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
